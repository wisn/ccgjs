{"version":3,"file":"ccgjs.umd.production.min.js","sources":["../src/ccg.reader.ts","../src/generated.pegjs.ts","../src/ccg.tree.ts","../src/index.ts","../src/ccg.dom.ts"],"sourcesContent":["import * as PEGjs from './generated.pegjs';\n\nexport enum DependencyHead {\n  Left = 0,\n  Right = 1,\n}\n\nexport type MachineReadableCCGNodeT = {\n  type?: string;\n  ccgCat: string;\n  head: DependencyHead;\n  dtrs: 0 | 1 | 2;\n};\n\nexport type MachineReadableCCGNodeL = {\n  type?: string;\n  ccgCat: string;\n  modPOSTag: string;\n  origPOSTag: string;\n  word: string;\n  predArgCat: string;\n};\n\nexport type MachineReadableCCG = {\n  node: MachineReadableCCGNodeT | MachineReadableCCGNodeL;\n  left?: MachineReadableCCG;\n  right?: MachineReadableCCG;\n};\n\nexport default class Reader {\n  public original: string;\n  public isSucceed: boolean = false;\n  public result?: MachineReadableCCG;\n\n  public constructor(str: string = '') {\n    this.original = str;\n  }\n\n  public read(): MachineReadableCCG | boolean {\n    let obj;\n    try {\n      obj = PEGjs.parse(this.original);\n    } catch {\n      return false;\n    }\n\n    this.result = obj;\n    this.isSucceed = true;\n\n    return obj;\n  }\n}\n","// @ts-nocheck\n\n// Generated by PEG.js v. 0.10.0 (ts-pegjs plugin v. 0.2.7 )\n//\n// https://pegjs.org/   https://github.com/metadevpro/ts-pegjs\n\n\"use strict\";\n\nexport interface IFilePosition {\n  offset: number;\n  line: number;\n  column: number;\n}\n\nexport interface IFileRange {\n  start: IFilePosition;\n  end: IFilePosition;\n}\n\nexport interface ILiteralExpectation {\n  type: \"literal\";\n  text: string;\n  ignoreCase: boolean;\n}\n\nexport interface IClassParts extends Array<string | IClassParts> {}\n\nexport interface IClassExpectation {\n  type: \"class\";\n  parts: IClassParts;\n  inverted: boolean;\n  ignoreCase: boolean;\n}\n\nexport interface IAnyExpectation {\n  type: \"any\";\n}\n\nexport interface IEndExpectation {\n  type: \"end\";\n}\n\nexport interface IOtherExpectation {\n  type: \"other\";\n  description: string;\n}\n\nexport type Expectation = ILiteralExpectation | IClassExpectation | IAnyExpectation | IEndExpectation | IOtherExpectation;\n\nexport class SyntaxError extends Error {\n  public static buildMessage(expected: Expectation[], found: string | null) {\n    function hex(ch: string): string {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s: string): string {\n      return s\n        .replace(/\\\\/g, \"\\\\\\\\\")\n        .replace(/\"/g,  \"\\\\\\\"\")\n        .replace(/\\0/g, \"\\\\0\")\n        .replace(/\\t/g, \"\\\\t\")\n        .replace(/\\n/g, \"\\\\n\")\n        .replace(/\\r/g, \"\\\\r\")\n        .replace(/[\\x00-\\x0F]/g,            (ch) => \"\\\\x0\" + hex(ch) )\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch) => \"\\\\x\"  + hex(ch) );\n    }\n\n    function classEscape(s: string): string {\n      return s\n        .replace(/\\\\/g, \"\\\\\\\\\")\n        .replace(/\\]/g, \"\\\\]\")\n        .replace(/\\^/g, \"\\\\^\")\n        .replace(/-/g,  \"\\\\-\")\n        .replace(/\\0/g, \"\\\\0\")\n        .replace(/\\t/g, \"\\\\t\")\n        .replace(/\\n/g, \"\\\\n\")\n        .replace(/\\r/g, \"\\\\r\")\n        .replace(/[\\x00-\\x0F]/g,            (ch) => \"\\\\x0\" + hex(ch) )\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch) => \"\\\\x\"  + hex(ch) );\n    }\n\n    function describeExpectation(expectation: Expectation) {\n      switch (expectation.type) {\n        case \"literal\":\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        case \"class\":\n          const escapedParts = expectation.parts.map((part) => {\n            return Array.isArray(part)\n              ? classEscape(part[0] as string) + \"-\" + classEscape(part[1] as string)\n              : classEscape(part);\n          });\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        case \"any\":\n          return \"any character\";\n        case \"end\":\n          return \"end of input\";\n        case \"other\":\n          return expectation.description;\n      }\n    }\n\n    function describeExpected(expected1: Expectation[]) {\n      const descriptions = expected1.map(describeExpectation);\n      let i: number;\n      let j: number;\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found1: string | null) {\n      return found1 ? \"\\\"\" + literalEscape(found1) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  }\n\n  public message: string;\n  public expected: Expectation[];\n  public found: string | null;\n  public location: IFileRange;\n  public name: string;\n\n  constructor(message: string, expected: Expectation[], found: string | null, location: IFileRange) {\n    super();\n    this.message = message;\n    this.expected = expected;\n    this.found = found;\n    this.location = location;\n    this.name = \"SyntaxError\";\n\n    if (typeof (Error as any).captureStackTrace === \"function\") {\n      (Error as any).captureStackTrace(this, SyntaxError);\n    }\n  }\n}\n\nexport interface ICached {\n  nextPos: number;\n  result: any;\n}\n\nfunction peg$parse(input: string, options?: IParseOptions) {\n  options = options !== undefined ? options : {};\n\n  const peg$FAILED: Readonly<{}> = {};\n\n  const peg$startRuleFunctions: {[id: string]: any} = { Start: peg$parseStart };\n  let peg$startRuleFunction: () => any = peg$parseStart;\n\n  const peg$c0 = \"(\";\n  const peg$c1 = peg$literalExpectation(\"(\", false);\n  const peg$c2 = \")\";\n  const peg$c3 = peg$literalExpectation(\")\", false);\n  const peg$c4 = function(node: any, left: any, right: any): any { return { node, left, right }; };\n  const peg$c5 = function(node: any, left: any, c: any): any { return { node, left, right: { node: c } }; };\n  const peg$c6 = function(node: any, c: any, right: any): any { return { node, left: { node: c }, right }; };\n  const peg$c7 = function(node: any, left: any): any { return { node, left }; };\n  const peg$c8 = function(node: any, c: any): any { return { node, ...c }; };\n  const peg$c9 = function(c1: any, c2: any): any { return { left: { node: c1 }, right: { node: c2 } }; };\n  const peg$c10 = function(c: any): any { return { left: { node: c } }; };\n  const peg$c11 = \"<\";\n  const peg$c12 = peg$literalExpectation(\"<\", false);\n  const peg$c13 = \"T\";\n  const peg$c14 = peg$literalExpectation(\"T\", false);\n  const peg$c15 = \">\";\n  const peg$c16 = peg$literalExpectation(\">\", false);\n  const peg$c17 = function(ccgCat: any, head: any, dtrs: any): any { return { type: \"T\", ccgCat, head, dtrs }; };\n  const peg$c18 = \"0\";\n  const peg$c19 = peg$literalExpectation(\"0\", false);\n  const peg$c20 = \"1\";\n  const peg$c21 = peg$literalExpectation(\"1\", false);\n  const peg$c22 = function(): any { return int(text()); };\n  const peg$c23 = \"2\";\n  const peg$c24 = peg$literalExpectation(\"2\", false);\n  const peg$c25 = \"L\";\n  const peg$c26 = peg$literalExpectation(\"L\", false);\n  const peg$c27 = function(ccgCat: any, modPOSTag: any, origPOSTag: any, word: any, predArgCat: any): any {\n        return {\n          type: \"L\",\n          ccgCat,\n          modPOSTag,\n          origPOSTag,\n          word,\n          predArgCat,\n        };\n      };\n  const peg$c28 = \"/\";\n  const peg$c29 = peg$literalExpectation(\"/\", false);\n  const peg$c30 = \"\\\\\";\n  const peg$c31 = peg$literalExpectation(\"\\\\\", false);\n  const peg$c32 = function(): any { return text(); };\n  const peg$c33 = /^[A-Za-z]/;\n  const peg$c34 = peg$classExpectation([[\"A\", \"Z\"], [\"a\", \"z\"]], false, false);\n  const peg$c35 = \"[\";\n  const peg$c36 = peg$literalExpectation(\"[\", false);\n  const peg$c37 = /^[A-Za-z,]/;\n  const peg$c38 = peg$classExpectation([[\"A\", \"Z\"], [\"a\", \"z\"], \",\"], false, false);\n  const peg$c39 = \"]\";\n  const peg$c40 = peg$literalExpectation(\"]\", false);\n  const peg$c41 = /^[A-Z]/;\n  const peg$c42 = peg$classExpectation([[\"A\", \"Z\"]], false, false);\n  const peg$c43 = /^[A-Za-z0-9]/;\n  const peg$c44 = peg$classExpectation([[\"A\", \"Z\"], [\"a\", \"z\"], [\"0\", \"9\"]], false, false);\n  const peg$c45 = peg$otherExpectation(\"whitespace\");\n  const peg$c46 = /^[ \\t\\n\\r]/;\n  const peg$c47 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false);\n  const peg$c48 = peg$otherExpectation(\"whitespaces\");\n\n  let peg$currPos = 0;\n  let peg$savedPos = 0;\n  const peg$posDetailsCache = [{ line: 1, column: 1 }];\n  let peg$maxFailPos = 0;\n  let peg$maxFailExpected: Expectation[] = [];\n  let peg$silentFails = 0;\n\n  const peg$resultsCache: {[id: number]: ICached} = {};\n\n  let peg$result;\n\n  if (options.startRule !== undefined) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text(): string {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location(): IFileRange {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description: string, location1?: IFileRange) {\n    location1 = location1 !== undefined\n      ? location1\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location1\n    );\n  }\n\n  function error(message: string, location1?: IFileRange) {\n    location1 = location1 !== undefined\n      ? location1\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location1);\n  }\n\n  function peg$literalExpectation(text1: string, ignoreCase: boolean): ILiteralExpectation {\n    return { type: \"literal\", text: text1, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts: IClassParts, inverted: boolean, ignoreCase: boolean): IClassExpectation {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation(): IAnyExpectation {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation(): IEndExpectation {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description: string): IOtherExpectation {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos: number) {\n    let details = peg$posDetailsCache[pos];\n    let p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos: number, endPos: number): IFileRange {\n    const startPosDetails = peg$computePosDetails(startPos);\n    const endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected1: Expectation) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected1);\n  }\n\n  function peg$buildSimpleError(message: string, location1: IFileRange) {\n    return new SyntaxError(message, [], \"\", location1);\n  }\n\n  function peg$buildStructuredError(expected1: Expectation[], found: string | null, location1: IFileRange) {\n    return new SyntaxError(\n      SyntaxError.buildMessage(expected1, found),\n      expected1,\n      found,\n      location1\n    );\n  }\n\n  function peg$parseStart(): any {\n    let s0;\n\n    const key = peg$currPos * 15 + 0;\n    const cached: ICached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parseTree();\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseTree(): any {\n    let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n    const key = peg$currPos * 15 + 1;\n    const cached: ICached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parse__();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s2 = peg$c0;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c1); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseNodeT();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseTree();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseTree();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s6 = peg$c2;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c3); }\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parse__();\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c4(s3, s4, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parse__();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c0;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c1); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseNodeT();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseTree();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 40) {\n                s5 = peg$c0;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c1); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseNodeL();\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s7 = peg$c2;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c3); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parse__();\n                    if (s8 !== peg$FAILED) {\n                      if (input.charCodeAt(peg$currPos) === 41) {\n                        s9 = peg$c2;\n                        peg$currPos++;\n                      } else {\n                        s9 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c3); }\n                      }\n                      if (s9 !== peg$FAILED) {\n                        s10 = peg$parse__();\n                        if (s10 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$c5(s3, s4, s6);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse__();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 40) {\n            s2 = peg$c0;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c1); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseNodeT();\n            if (s3 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 40) {\n                s4 = peg$c0;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c1); }\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parseNodeL();\n                if (s5 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s6 = peg$c2;\n                    peg$currPos++;\n                  } else {\n                    s6 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c3); }\n                  }\n                  if (s6 !== peg$FAILED) {\n                    s7 = peg$parseTree();\n                    if (s7 !== peg$FAILED) {\n                      if (input.charCodeAt(peg$currPos) === 41) {\n                        s8 = peg$c2;\n                        peg$currPos++;\n                      } else {\n                        s8 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c3); }\n                      }\n                      if (s8 !== peg$FAILED) {\n                        s9 = peg$parse__();\n                        if (s9 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$c6(s3, s5, s7);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse__();\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 40) {\n              s2 = peg$c0;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c1); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseNodeT();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parseTree();\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c2;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c3); }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parse__();\n                    if (s6 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c7(s3, s4);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse__();\n            if (s1 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 40) {\n                s2 = peg$c0;\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c1); }\n              }\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parseNodeT();\n                if (s3 !== peg$FAILED) {\n                  s4 = peg$parseNode();\n                  if (s4 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 41) {\n                      s5 = peg$c2;\n                      peg$currPos++;\n                    } else {\n                      s5 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c3); }\n                    }\n                    if (s5 !== peg$FAILED) {\n                      s6 = peg$parse__();\n                      if (s6 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c8(s3, s4);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseNode(): any {\n    let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n    const key = peg$currPos * 15 + 2;\n    const cached: ICached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parse__();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s2 = peg$c0;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c1); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseNodeL();\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s4 = peg$c2;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c3); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse__();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 40) {\n                s6 = peg$c0;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c1); }\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseNodeL();\n                if (s7 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s8 = peg$c2;\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c3); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parse__();\n                    if (s9 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c9(s3, s7);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parse__();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c0;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c1); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseNodeL();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s4 = peg$c2;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c3); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse__();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c10(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseNodeT(): any {\n    let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n    const key = peg$currPos * 15 + 3;\n    const cached: ICached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parse__();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 60) {\n        s2 = peg$c11;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c12); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse__();\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 84) {\n            s4 = peg$c13;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c14); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseCCGCat();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parse_();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseHead();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parse_();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parseDtrs();\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parse__();\n                        if (s11 !== peg$FAILED) {\n                          if (input.charCodeAt(peg$currPos) === 62) {\n                            s12 = peg$c15;\n                            peg$currPos++;\n                          } else {\n                            s12 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n                          }\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parse__();\n                            if (s13 !== peg$FAILED) {\n                              peg$savedPos = s0;\n                              s1 = peg$c17(s6, s8, s10);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseHead(): any {\n    let s0, s1;\n\n    const key = peg$currPos * 15 + 4;\n    const cached: ICached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 48) {\n      s1 = peg$c18;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c19); }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 49) {\n        s1 = peg$c20;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c22();\n    }\n    s0 = s1;\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseDtrs(): any {\n    let s0, s1;\n\n    const key = peg$currPos * 15 + 5;\n    const cached: ICached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 48) {\n      s1 = peg$c18;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c19); }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 49) {\n        s1 = peg$c20;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 50) {\n          s1 = peg$c23;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c24); }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c22();\n    }\n    s0 = s1;\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseNodeL(): any {\n    let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;\n\n    const key = peg$currPos * 15 + 6;\n    const cached: ICached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parse__();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 60) {\n        s2 = peg$c11;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c12); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse__();\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 76) {\n            s4 = peg$c25;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c26); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseCCGCat();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parse_();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsePOSTag();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parse_();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsePOSTag();\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parse_();\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parseWord();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parse_();\n                            if (s13 !== peg$FAILED) {\n                              s14 = peg$parseCCGCat();\n                              if (s14 !== peg$FAILED) {\n                                s15 = peg$parse__();\n                                if (s15 !== peg$FAILED) {\n                                  if (input.charCodeAt(peg$currPos) === 62) {\n                                    s16 = peg$c15;\n                                    peg$currPos++;\n                                  } else {\n                                    s16 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c16); }\n                                  }\n                                  if (s16 !== peg$FAILED) {\n                                    s17 = peg$parse__();\n                                    if (s17 !== peg$FAILED) {\n                                      peg$savedPos = s0;\n                                      s1 = peg$c27(s6, s8, s10, s12, s14);\n                                      s0 = s1;\n                                    } else {\n                                      peg$currPos = s0;\n                                      s0 = peg$FAILED;\n                                    }\n                                  } else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                  }\n                                } else {\n                                  peg$currPos = s0;\n                                  s0 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseCCGCat(): any {\n    let s0, s1, s2, s3, s4, s5;\n\n    const key = peg$currPos * 15 + 7;\n    const cached: ICached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s2 = peg$c0;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c1); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseCCGCat();\n      if (s3 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s4 = peg$c2;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c3); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseRightCat();\n          if (s5 !== peg$FAILED) {\n            s2 = [s2, s3, s4, s5];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parseLeftCat();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s3 = peg$c0;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c1); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseCCGCat();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s5 = peg$c2;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c3); }\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c0;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c1); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseCCGCat();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s4 = peg$c2;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c3); }\n            }\n            if (s4 !== peg$FAILED) {\n              s2 = [s2, s3, s4];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = peg$parseSingleCat();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s3 = peg$c28;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c29); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseSingleCat();\n              if (s4 !== peg$FAILED) {\n                s2 = [s2, s3, s4];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n          if (s1 === peg$FAILED) {\n            s1 = peg$currPos;\n            s2 = peg$parseSingleCat();\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 92) {\n                s3 = peg$c30;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c31); }\n              }\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parseSingleCat();\n                if (s4 !== peg$FAILED) {\n                  s2 = [s2, s3, s4];\n                  s1 = s2;\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n            if (s1 === peg$FAILED) {\n              s1 = peg$parseSingleCat();\n            }\n          }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c32();\n    }\n    s0 = s1;\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseLeftCat(): any {\n    let s0, s1, s2;\n\n    const key = peg$currPos * 15 + 8;\n    const cached: ICached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseSingleCat();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s2 = peg$c28;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseSingleCat();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s2 = peg$c30;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c31); }\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseRightCat(): any {\n    let s0, s1, s2;\n\n    const key = peg$currPos * 15 + 9;\n    const cached: ICached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 47) {\n      s1 = peg$c28;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c29); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseSingleCat();\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c30;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c31); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseSingleCat();\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseSingleCat(): any {\n    let s0, s1, s2, s3, s4;\n\n    const key = peg$currPos * 15 + 10;\n    const cached: ICached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c33.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c33.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c34); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s2 = peg$c35;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        if (peg$c37.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c37.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c38); }\n            }\n          }\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s4 = peg$c39;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c40); }\n          }\n          if (s4 !== peg$FAILED) {\n            s1 = [s1, s2, s3, s4];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = [];\n      if (peg$c33.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c34); }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$c33.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c34); }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsePOSTag(): any {\n    let s0, s1, s2;\n\n    const key = peg$currPos * 15 + 11;\n    const cached: ICached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c41.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c42); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c41.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c42); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c32();\n    }\n    s0 = s1;\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseWord(): any {\n    let s0, s1, s2;\n\n    const key = peg$currPos * 15 + 12;\n    const cached: ICached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c43.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c44); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c43.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c44); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c32();\n    }\n    s0 = s1;\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parse_(): any {\n    let s0, s1;\n\n    const key = peg$currPos * 15 + 13;\n    const cached: ICached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    peg$silentFails++;\n    s0 = [];\n    if (peg$c46.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c47); }\n    }\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c46.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c47); }\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c45); }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parse__(): any {\n    let s0, s1;\n\n    const key = peg$currPos * 15 + 14;\n    const cached: ICached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    peg$silentFails++;\n    s0 = [];\n    if (peg$c46.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c47); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c46.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c47); }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n\n    function int(x) {\n      return parseInt(x, 10);\n    }\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nexport interface IParseOptions {\n  filename?: string;\n  startRule?: string;\n  tracer?: any;\n  [key: string]: any;\n}\nexport type ParseFunction = (input: string, options?: IParseOptions) => any;\nexport const parse: ParseFunction = peg$parse;\n\n","import Reader, {\n  MachineReadableCCGNodeT,\n  MachineReadableCCGNodeL,\n  MachineReadableCCG,\n} from './ccg.reader';\n\nexport type NodeT = MachineReadableCCGNodeT & { nIndex?: number };\n\nexport type NodeL = MachineReadableCCGNodeL & {\n  nIndex?: number;\n  wIndex?: number;\n};\n\nexport type Node = {\n  value: NodeT | NodeL;\n  left?: Node;\n  right?: Node;\n};\n\nexport type Derivation = {\n  from: number;\n  to: number;\n  ccgCat: string;\n  opr?: string;\n};\n\nexport type Metadata = {\n  isParsed: boolean;\n  sentence: string;\n  words: Array<string>;\n  ccgCats: Array<string>;\n  derivations?: Array<Array<Derivation>>;\n  height: number;\n  nodes: Array<Node>;\n};\n\nexport type IndexedWordMapper = { [key: number]: Node };\n\nexport type ToStringOptions = { pretty?: boolean };\n\nexport default class Tree {\n  public root?: Node;\n  public metadata?: Metadata;\n  public mappedIndexedWords?: IndexedWordMapper;\n  private stringBuilder?: string;\n\n  constructor(str: string = '') {\n    if (str.length > 0) {\n      this.metadata = {\n        isParsed: false,\n        sentence: '',\n        words: [],\n        ccgCats: [],\n        height: 0,\n        nodes: [],\n      };\n      this.constructTree(str);\n    }\n  }\n\n  public traverse(fn: Function): any {\n    return fn(this.root);\n  }\n\n  public toString(opts?: ToStringOptions): string {\n    if (this.root) {\n      this.stringBuilder = '';\n      this.toStringUtil(this.root, 0, opts);\n\n      return this.stringBuilder.substring(1);\n    }\n\n    return '';\n  }\n\n  public buildDerivations(): Array<Array<Derivation>> {\n    if (!this.root) {\n      return [];\n    }\n\n    this.metadata!.derivations = [];\n    for (let i = 0; i < this.metadata!.height!; i++) {\n      this.metadata!.derivations.push([]);\n    }\n\n    this.buildDerivUtil(this.root!);\n\n    return this.metadata!.derivations;\n  }\n\n  private constructTree(str: string): void {\n    const reader = new Reader(str);\n    if (reader.read()) {\n      const result: MachineReadableCCG = reader.result as MachineReadableCCG;\n\n      this.buildTree(result);\n      this.metadata!.isParsed = true;\n    }\n  }\n\n  private buildTree(obj: MachineReadableCCG): void {\n    this.buildTreeUtil(obj, 1);\n  }\n\n  private buildTreeUtil(\n    obj: MachineReadableCCG,\n    level: number,\n    parent?: Node,\n    dir?: string\n  ): void {\n    const node: Node = { value: obj.node };\n    if (this.root === undefined) {\n      this.mappedIndexedWords = {};\n      this.root = node;\n    }\n\n    const nIndex = this.metadata?.nodes.length;\n    node.value.nIndex = nIndex;\n    this.metadata?.nodes.push(node);\n\n    if (this.isNodeL(node)) {\n      const nodeL: NodeL = node.value as NodeL;\n      const wIndex = this.metadata!.words.length;\n\n      nodeL.wIndex = wIndex;\n      this.metadata!.words.push(nodeL.word);\n      this.metadata!.ccgCats.push(nodeL.ccgCat);\n      this.mappedIndexedWords![wIndex] = node;\n\n      if (this.metadata?.sentence === '') {\n        this.metadata!.sentence = nodeL.word;\n      } else {\n        this.metadata!.sentence += ` ${nodeL.word}`;\n      }\n    }\n\n    this.metadata!.height = Math.max(this.metadata?.height!, level);\n\n    if (dir === 'left') {\n      parent!.left = node;\n    }\n\n    if (dir === 'right') {\n      parent!.right = node;\n    }\n\n    obj.left && this.buildTreeUtil(obj.left, level + 1, node, 'left');\n    obj.right && this.buildTreeUtil(obj.right, level + 1, node, 'right');\n  }\n\n  private toStringUtil(\n    node: Node,\n    level: number,\n    opts?: ToStringOptions\n  ): void {\n    if (opts?.pretty) {\n      const indents = 2 * level;\n      this.stringBuilder += '\\n' + ' '.repeat(indents) + '(';\n    } else {\n      this.stringBuilder += ' (';\n    }\n\n    if (this.isNodeT(node)) {\n      const n: NodeT = node.value as NodeT;\n      this.stringBuilder += [\n        '<T',\n        `${n.ccgCat}`,\n        `${n.head}`,\n        `${n.dtrs}>`,\n      ].join(' ');\n    } else if (this.isNodeL(node)) {\n      const n: NodeL = node.value as NodeL;\n      this.stringBuilder += [\n        '<L',\n        `${n.ccgCat}`,\n        `${n.modPOSTag}`,\n        `${n.origPOSTag}`,\n        `${n.word}`,\n        `${n.predArgCat}>`,\n      ].join(' ');\n    } else {\n      this.stringBuilder += '<ill-formed CCG Node>';\n    }\n\n    node.left && this.toStringUtil(node.left, level + 1, opts);\n    node.right && this.toStringUtil(node.right, level + 1, opts);\n\n    this.stringBuilder += ')';\n  }\n\n  private isNodeT(node: Node): boolean {\n    return (node.value as NodeT).head !== undefined;\n  }\n\n  private isNodeL(node: Node): boolean {\n    return (node.value as NodeL).word !== undefined;\n  }\n\n  private buildDerivUtil(node: Node, dir?: string): Array<number> {\n    if (this.isNodeL(node)) {\n      const nodeL: NodeL = node.value as NodeL;\n      const index = nodeL.wIndex!;\n\n      const derivation: Derivation = {\n        from: index,\n        to: index,\n        ccgCat: nodeL.ccgCat,\n      };\n      this.metadata!.derivations![0].push(derivation);\n\n      if (dir === 'left') {\n        return [index, -1, 1];\n      }\n\n      return [-1, index, 1];\n    }\n\n    const derivLeft = this.buildDerivUtil(node.left!, 'left');\n    let derivRight: Array<null> | Array<number> = [null, null, null];\n\n    if (node.right) {\n      derivRight = this.buildDerivUtil(node.right!, 'right');\n    }\n\n    const derivation: Derivation = {\n      from: derivLeft[0],\n      to: derivRight[1] ?? derivLeft[0],\n      ccgCat: node.value.ccgCat,\n      opr: (node.value as NodeT).head !== 0 ? '<' : '>',\n    };\n    const bottom = Math.max(derivLeft[2], derivRight[2] ?? -1);\n\n    this.metadata!.derivations![bottom].push(derivation);\n\n    return [derivation.from, derivation.to, bottom + 1];\n  }\n}\n","import DOM from './ccg.dom';\nimport Reader, * as ReaderTypes from './ccg.reader';\nimport Tree, * as TreeTypes from './ccg.tree';\n\nexport const CCG = {\n  DOM,\n  Reader,\n  ReaderTypes,\n  Tree,\n  TreeTypes,\n};\n\nexport default CCG;\n","import Tree from './ccg.tree';\n\nexport default class DOM {\n  public tree?: Tree;\n  private domBuilder?: HTMLElement;\n\n  public constructor(tree: string | Tree) {\n    if (typeof tree === 'string') {\n      if (tree.length > 0) {\n        this.tree = new Tree(tree);\n      }\n    } else {\n      this.tree = tree;\n    }\n\n    this.tree?.buildDerivations();\n  }\n\n  public create(fn?: Function): any {\n    if (fn) {\n      return fn(this.tree);\n    }\n\n    return this.createTable();\n  }\n\n  public createTable(): HTMLElement {\n    const table = document.createElement('table');\n    table.className = 'ccgjs';\n    this.domBuilder = table;\n\n    let lastTo: number;\n    let hrTr: HTMLTableRowElement;\n    const numOfWords = this.tree!.metadata!.words.length;\n    const wordTr = document.createElement('tr');\n\n    this.tree?.metadata?.words.forEach(word => {\n      const wordTd = document.createElement('td');\n      const text = document.createTextNode(word);\n      wordTd.appendChild(text);\n      wordTr.appendChild(wordTd);\n\n      const oprTd = document.createElement('td');\n      oprTd.className = 'ccgjs-operation';\n      wordTr.appendChild(oprTd);\n    });\n\n    wordTr.className = 'ccgjs-words';\n    this.domBuilder.appendChild(wordTr);\n\n    this.tree?.metadata?.derivations?.forEach(row => {\n      const derivTr = document.createElement('tr');\n      derivTr.className = 'ccgjs-derivation';\n\n      lastTo = 0;\n      hrTr = document.createElement('tr');\n      hrTr.className = 'ccgjs-ruler';\n\n      row.forEach(deriv => {\n        const { from, to } = deriv;\n        const diff = from - lastTo;\n\n        if (diff > 1) {\n          const derivTd = document.createElement('td');\n          derivTd.colSpan = diff * 2;\n          derivTr.appendChild(derivTd);\n\n          const hrTd = document.createElement('td');\n          hrTd.colSpan = diff * 2;\n          hrTr.appendChild(hrTd);\n        }\n\n        const derivTd = document.createElement('td');\n        const text = document.createTextNode(deriv.ccgCat);\n        derivTd.appendChild(text);\n\n        const hr = document.createElement('hr');\n        const hrTd = document.createElement('td');\n        hrTd.appendChild(hr);\n\n        const oprTd = document.createElement('td');\n        oprTd.className = 'ccgjs-operation';\n        const opr = document.createTextNode(deriv.opr ?? '');\n        oprTd.appendChild(opr);\n\n        const fakeOpr = document.createElement('td');\n        fakeOpr.className = 'ccgjs-operation';\n\n        if (to - from > 0) {\n          const diffM = (to - from + 1) * 2 - 1;\n          derivTd.colSpan = diffM;\n          hrTd.colSpan = diffM;\n        }\n\n        hrTr.appendChild(hrTd);\n        hrTr.appendChild(oprTd);\n        derivTr.appendChild(derivTd);\n        derivTr.appendChild(fakeOpr);\n\n        lastTo = to;\n      });\n\n      if (lastTo + 1 < numOfWords) {\n        const diff = (numOfWords - (lastTo + 1)) * 2;\n\n        const derivTd = document.createElement('td');\n        derivTd.colSpan = diff;\n        derivTr.appendChild(derivTd);\n\n        const hrTd = document.createElement('td');\n        hrTd.colSpan = diff;\n        hrTr.appendChild(hrTd);\n      }\n\n      this.domBuilder?.appendChild(hrTr);\n      this.domBuilder?.appendChild(derivTr);\n    });\n\n    return this.domBuilder;\n  }\n}\n"],"names":["DependencyHead","SyntaxError","message","expected","found","location","name","Error","captureStackTrace","buildMessage","hex","ch","charCodeAt","toString","toUpperCase","literalEscape","s","replace","classEscape","describeExpectation","expectation","type","text","escapedParts","parts","map","part","Array","isArray","inverted","description","expected1","i","j","descriptions","sort","length","slice","join","describeExpected","found1","Reader","str","original","read","obj","input","options","undefined","peg$result","location1","startPos","endPos","startPosDetails","endPosDetails","peg$FAILED","peg$startRuleFunctions","Start","peg$parseStart","peg$startRuleFunction","peg$c1","peg$literalExpectation","peg$c3","peg$c12","peg$c14","peg$c16","peg$c19","peg$c21","peg$c22","x","parseInt","peg$c24","peg$c26","peg$c29","peg$c31","peg$c32","peg$c33","peg$c34","peg$classExpectation","peg$c36","peg$c37","peg$c38","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$otherExpectation","peg$c46","peg$c47","peg$c48","peg$currPos","peg$savedPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","peg$resultsCache","startRule","substring","text1","ignoreCase","peg$computePosDetails","pos","p","details","peg$fail","push","s0","key","cached","nextPos","result","peg$parseTree","s2","s3","s4","s5","s6","s7","s8","s9","peg$parse__","peg$parseNodeT","node","left","right","peg$parseNodeL","c","peg$c5","peg$c6","peg$c7","peg$parseNode","peg$c8","s10","s12","peg$parse_","peg$parseCCGCat","s1","peg$parseHead","peg$parseDtrs","ccgCat","head","dtrs","s14","s16","peg$parsePOSTag","test","charAt","peg$parseWord","modPOSTag","origPOSTag","word","predArgCat","peg$parseSingleCat","peg$parseRightCat","peg$parseLeftCat","start","offset","end","PEGjs","this","isSucceed","Tree","metadata","isParsed","sentence","words","ccgCats","height","nodes","constructTree","traverse","fn","root","opts","stringBuilder","toStringUtil","buildDerivations","derivations","buildDerivUtil","reader","buildTree","buildTreeUtil","level","parent","dir","value","mappedIndexedWords","nIndex","_this$metadata","isNodeL","nodeL","wIndex","Math","max","_this$metadata4","pretty","repeat","isNodeT","n","index","from","to","derivLeft","derivRight","derivation","opr","bottom","CCG","DOM","tree","create","createTable","lastTo","hrTr","table","document","createElement","className","domBuilder","numOfWords","wordTr","forEach","wordTd","createTextNode","appendChild","oprTd","row","derivTr","deriv","diff","derivTd","colSpan","hrTd","hr","fakeOpr","diffM","_this","ReaderTypes","TreeTypes"],"mappings":"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"}